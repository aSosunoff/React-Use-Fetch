{"version":3,"sources":["webpack:///./hooks/use-fetch-reducer.ts","webpack:///./hooks/use-trigger.ts","webpack:///./hooks/use-why-did-you-update.ts","webpack:///./use-callback-async/index.ts","webpack:///./use-callback-async/use-params.ts","webpack:///./use-fetch/index.ts","webpack:///./use-fetch/use-headers.ts","webpack:///./use-parse-jwt/index.ts","webpack:///./use-parse-jwt/parse-jwt.ts","webpack:///./utils/tuple.ts","webpack:///external \"react\"","webpack:///webpack/bootstrap","webpack:///./index.ts"],"names":["useFetchReducer","initialState","useMemo","status","error","undefined","data","fetchReducer","useCallback","state","action","type","payload","useReducer","dispatch","request","success","failure","useTrigger","useState","setState","onHandler","offHandler","togglerHandler","prev","tuple","useWhyDidYouUpdate","props","callback","previousProps","useRef","useEffect","current","allKeys","Object","keys","forEach","key","from","to","length","useCallbackAsync","isStartFetch","fetchStart","fetchFinish","useParams","params","setParamsHandler","clearParamsHandler","cancelRequest","doFetch","setParams","fetchHandler","url","options","setHeadersHandlerCallback","responseType","optionsFetch","fetch","toString","response","headers","ok","json","text","formData","blob","arrayBuffer","Error","useFetch","useHeaders","setHeadersHandler","doFetchHandler","setHeaders","headersFinal","Array","entries","reduce","res","value","clearHeadersHandler","useParseJWT","token","parseJWT","base64","split","replace","jsonPayload","decodeURIComponent","atob","map","c","charCodeAt","slice","join","JSON","parse","console","log","args","module","exports","__WEBPACK_EXTERNAL_MODULE__297__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"mappings":"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","file":"index.min.js","sourcesContent":["import { useCallback, useMemo, useReducer } from \"react\";\n\nexport interface State<TData, TError = any> {\n  status: \"init\" | \"request\" | \"failure\" | \"success\";\n  data?: TData;\n  error?: TError;\n}\n\nexport type Action<K extends string, V = void> = V extends void\n  ? { type: K }\n  : { type: K } & V;\n\nexport type ActionFetch<T> =\n  | Action<\"request\">\n  | Action<\"success\", { payload: T }>\n  | Action<\"failure\", { payload: any }>;\n\nexport const useFetchReducer = <TData, TError>() => {\n  const initialState = useMemo<State<TData, TError>>(\n    () => ({\n      status: \"init\",\n      error: undefined,\n      data: undefined,\n    }),\n    []\n  );\n\n  const fetchReducer = useCallback(\n    (\n      state: State<TData, TError>,\n      action: ActionFetch<TData>\n    ): State<TData, TError> => {\n      switch (action.type) {\n        case \"request\":\n          return { ...initialState, status: \"request\", data: state.data };\n        case \"success\":\n          return { ...initialState, status: \"success\", data: action.payload };\n        case \"failure\":\n          return { ...initialState, status: \"failure\", error: action.payload };\n        default:\n          return state;\n      }\n    },\n    [initialState]\n  );\n\n  const [state, dispatch] = useReducer(fetchReducer, initialState);\n\n  const request = useCallback(() => dispatch({ type: \"request\" }), []);\n\n  const success = useCallback(\n    (payload?) => dispatch({ type: \"success\", payload }),\n    []\n  );\n\n  const failure = useCallback(\n    (payload?) => dispatch({ type: \"failure\", payload }),\n    []\n  );\n\n  return {\n    state,\n    request,\n    success,\n    failure,\n  };\n};\n","import { useState, useCallback } from \"react\";\nimport { tuple } from \"../utils/tuple\";\n\nexport const useTrigger = (initialState = false) => {\n  const [state, setState] = useState(initialState);\n\n  const onHandler = useCallback(() => setState(() => true), []);\n\n  const offHandler = useCallback(() => setState(() => false), []);\n\n  const togglerHandler = useCallback(() => setState((prev) => !prev), []);\n\n  return tuple(state, {\n    onHandler,\n    offHandler,\n    togglerHandler,\n  });\n};\n","import { useEffect, useRef } from \"react\";\n\nexport type IChangeProps<TProps extends Record<string, any>> = {\n  [key in keyof TProps]: {\n    from: TProps[key];\n    to: TProps[key];\n  };\n};\n\nexport const useWhyDidYouUpdate = <TProps extends Record<string, any>>(\n  props: TProps,\n  callback: (change: IChangeProps<TProps>) => void\n) => {\n  const previousProps = useRef<TProps>({} as TProps);\n\n  useEffect(() => {\n    if (previousProps.current) {\n      const allKeys = Object.keys({ ...previousProps.current, ...props });\n\n      const changeObj: IChangeProps<any> = {};\n\n      allKeys.forEach((key) => {\n        if (previousProps.current[key] !== props[key]) {\n          changeObj[key] = {\n            from: previousProps.current[key],\n            to: props[key],\n          };\n        }\n      });\n\n      if (Object.keys(changeObj).length) {\n        callback(changeObj);\n      }\n    }\n\n    previousProps.current = props;\n  }, [props, callback]);\n};\n","import { useCallback, useEffect } from \"react\";\nimport { useTrigger } from \"../hooks/use-trigger\";\nimport { tuple } from \"../utils/tuple\";\nimport { useFetchReducer } from \"../hooks/use-fetch-reducer\";\nimport { useParams } from \"./use-params\";\n\nexport const useCallbackAsync = <\n  TData,\n  TError = any,\n  TParams extends any[] = any[]\n>(\n  callback: (...params: TParams) => Promise<TData>\n) => {\n  const { state, request, success, failure } = useFetchReducer<TData, TError>();\n\n  const [isStartFetch, { onHandler: fetchStart, offHandler: fetchFinish }] =\n    useTrigger();\n\n  const { params, setParamsHandler, clearParamsHandler } = useParams<TParams>();\n\n  useEffect(() => {\n    if (!isStartFetch) return;\n\n    let cancelRequest = false;\n\n    (async (...params: TParams) => {\n      try {\n        const data = await callback(...params);\n\n        if (cancelRequest) return;\n\n        fetchFinish();\n        success(data);\n        clearParamsHandler();\n      } catch (error) {\n        if (cancelRequest) return;\n\n        fetchFinish();\n        failure(error);\n        clearParamsHandler();\n      }\n    })(...params);\n\n    return () => {\n      cancelRequest = true;\n    };\n  }, [\n    callback,\n    failure,\n    fetchFinish,\n    isStartFetch,\n    success,\n    params,\n    clearParamsHandler,\n  ]);\n\n  const doFetch = useCallback(\n    (...params: TParams) => {\n      setParamsHandler(params);\n      request();\n      fetchStart();\n    },\n    [request, fetchStart, setParamsHandler]\n  );\n\n  return tuple(state, doFetch);\n};\n","import { useCallback, useState } from \"react\";\n\nexport const useParams = <TParams extends any[] = any[]>() => {\n  const [params, setParams] = useState<TParams>([] as any);\n\n  const setParamsHandler = useCallback((params: TParams) => {\n    setParams(() => params);\n  }, []);\n\n  const clearParamsHandler = useCallback(() => {\n    setParams(() => [] as any);\n  }, []);\n\n  return {\n    params,\n    setParamsHandler,\n    clearParamsHandler,\n  };\n};\n","import { useCallbackAsync } from \"./../use-callback-async/index\";\nimport { useCallback } from \"react\";\nimport { tuple } from \"../utils/tuple\";\nimport { useHeaders } from \"./use-headers\";\n\ninterface UseFetchOption extends RequestInit {\n  responseType?: \"text\" | \"json\" | \"formData\" | \"blob\" | \"arrayBuffer\";\n}\n\nconst fetchHandler = async (\n  url: string,\n  options: UseFetchOption,\n  setHeadersHandlerCallback: (headers: Headers) => void\n) => {\n  const { responseType, ...optionsFetch } = options;\n\n  const response = await fetch(url.toString(), optionsFetch);\n\n  setHeadersHandlerCallback(response.headers);\n\n  if (!response.ok) {\n    const body = await response.json();\n    throw body;\n  }\n\n  let data = null;\n\n  switch (responseType) {\n    case \"text\":\n      data = await response.text();\n      break;\n    case \"json\":\n      data = await response.json();\n      break;\n    case \"formData\":\n      data = await response.formData();\n      break;\n    case \"blob\":\n      data = await response.blob();\n      break;\n    case \"arrayBuffer\":\n      data = await response.arrayBuffer();\n      break;\n    default:\n      throw new Error(\"Not found type of response\");\n  }\n\n  return data;\n};\n\nexport const useFetch = <TData, TError = any>(url: string) => {\n  const { headers, setHeadersHandler } = useHeaders();\n\n  const [state, doFetch] = useCallbackAsync<\n    TData,\n    TError,\n    [string, UseFetchOption, (headers: Headers) => void]\n  >(fetchHandler);\n\n  const doFetchHandler = useCallback(\n    (options?: UseFetchOption) =>\n      doFetch(\n        url,\n        {\n          responseType: \"json\",\n          ...options,\n        },\n        setHeadersHandler\n      ),\n    [doFetch, setHeadersHandler, url]\n  );\n\n  return tuple(state, doFetchHandler, headers);\n};\n\n/* export const useFetch = <TData, TError = any>(url: string) => {\n  const [options, setOptions] = useState<UseFetchOption>({} as UseFetchOption);\n\n  const { headers, setHeadersHandler, clearHeadersHandler } = useHeaders();\n\n  const { state, request, success, failure } = useFetchReducer<TData, TError>();\n\n  const [isFetch, { onHandler: fetchStart, offHandler: fetchFinish }] =\n    useTrigger();\n\n  useEffect(() => {\n    if (!isFetch) return;\n\n    let cancelRequest = false;\n\n    (async () => {\n      try {\n        const { responseType, ...optionsFetch } = options;\n\n        const response = await fetch(url.toString(), optionsFetch);\n\n        setHeadersHandler(response.headers);\n\n        if (!response.ok) {\n          const body = await response.json();\n          throw body;\n        }\n\n        let data = null;\n\n        switch (responseType) {\n          case \"text\":\n            data = await response.text();\n            break;\n          case \"json\":\n            data = await response.json();\n            break;\n          case \"formData\":\n            data = await response.formData();\n            break;\n          case \"blob\":\n            data = await response.blob();\n            break;\n          case \"arrayBuffer\":\n            data = await response.arrayBuffer();\n            break;\n          default:\n            throw new Error(\"Not found type of response\");\n        }\n\n        if (cancelRequest) return;\n\n        fetchFinish();\n        success(data);\n      } catch (error) {\n        if (cancelRequest) return;\n\n        fetchFinish();\n        clearHeadersHandler();\n        failure(error);\n      }\n    })();\n\n    return () => {\n      cancelRequest = true;\n    };\n  }, [\n    clearHeadersHandler,\n    failure,\n    isFetch,\n    options,\n    setHeadersHandler,\n    success,\n    url,\n    fetchFinish,\n  ]);\n\n  const doFetch = useCallback(\n    (options?: UseFetchOption) => {\n      request();\n\n      setOptions(() => ({\n        responseType: \"json\",\n        ...options,\n      }));\n\n      fetchStart();\n    },\n    [request, fetchStart]\n  );\n\n  return tuple(state, doFetch, headers);\n}; */\n","import { useCallback, useState } from \"react\";\n\ntype useHeadersState = {\n  [key: string]: string;\n} | null;\n\nexport const useHeaders = () => {\n  const [headers, setHeaders] = useState<useHeadersState>(null);\n\n  const setHeadersHandler = useCallback((headers: Headers) => {\n    const headersFinal = Array.from(headers.entries()).reduce(\n      (res, [key, value]) => ({\n        ...res,\n        [key]: value,\n      }),\n      {}\n    );\n\n    setHeaders(() => headersFinal);\n  }, []);\n\n  const clearHeadersHandler = useCallback(() => {\n    setHeaders(() => null);\n  }, []);\n\n  return {\n    headers,\n    setHeadersHandler,\n    clearHeadersHandler,\n  };\n};\n","import { useMemo } from \"react\";\nimport { parseJWT } from \"./parse-jwt\";\n\nexport const useParseJWT = <T>(token: string) => {\n  const JWT = useMemo(() => parseJWT<T>(token), [token]);\n\n  return JWT;\n};\n","export const parseJWT = <T>(token: string): T | null => {\n  try {\n    if (!token) return null;\n\n    const base64Url = token.split(\".\")[1];\n    const base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const jsonPayload = decodeURIComponent(\n      atob(base64)\n        .split(\"\")\n        .map((c) => \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2))\n        .join(\"\")\n    );\n\n    return JSON.parse(jsonPayload);\n  } catch (error) {\n    console.log(error);\n    return null;\n  }\n};\n","export const tuple = <T extends unknown[]>(...args: T): T => args;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__297__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","export { useFetch } from \"./use-fetch\";\nexport { useCallbackAsync } from \"./use-callback-async\";\nexport { useFetchReducer } from \"./hooks/use-fetch-reducer\";\nexport { useTrigger } from \"./hooks/use-trigger\";\nexport { useWhyDidYouUpdate } from \"./hooks/use-why-did-you-update\";\nexport { useParseJWT } from \"./use-parse-jwt\";\n"],"sourceRoot":""}