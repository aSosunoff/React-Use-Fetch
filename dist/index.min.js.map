{"version":3,"sources":["webpack:///./hooks/use-change-array-length.ts","webpack:///./hooks/use-did-update.ts","webpack:///./hooks/use-fetch-reducer.ts","webpack:///./hooks/use-local-storage.ts","webpack:///./hooks/use-prev-state.ts","webpack:///./hooks/use-trigger.ts","webpack:///./hooks/use-why-did-you-update.ts","webpack:///./index.ts","webpack:///./use-callback-async/index.ts","webpack:///./use-callback-async/use-params.ts","webpack:///./use-fetch/index.ts","webpack:///./use-fetch/use-headers.ts","webpack:///./use-pagination/chunkFromArray.ts","webpack:///./use-pagination/index.ts","webpack:///./use-parse-jwt/index.ts","webpack:///./use-parse-jwt/parse-jwt.ts","webpack:///./utils/tuple.ts","webpack:///external \"react\"","webpack:///webpack/bootstrap","webpack:///webpack/startup"],"names":["useChangeArrayLength","arr","fn","prevArrayLength","usePrevState","length","useEffect","undefined","useDidUpdate","effect","dependencies","hasMounted","useRef","current","useFetchReducer","initialState","useMemo","status","error","data","fetchReducer","useCallback","state","action","type","payload","useReducer","dispatch","request","success","failure","useLocalStorage","key","initialValue","useState","item","localStorage","getItem","JSON","parse","console","storedValue","setStoredValue","setItem","stringify","log","setValue","value","tuple","prev","useTrigger","setState","onHandler","offHandler","togglerHandler","useWhyDidYouUpdate","props","callback","previousProps","allKeys","Object","keys","forEach","from","to","useFetch","useCallbackAsync","useParseJWT","usePagination","isStartFetch","fetchStart","fetchFinish","useParams","params","setParamsHandler","clearParamsHandler","cancelRequest","doFetch","setParams","fetchHandler","url","options","setHeadersHandlerCallback","responseType","optionsFetch","fetch","toString","response","headers","ok","json","text","formData","blob","arrayBuffer","Error","useHeaders","setHeadersHandler","doFetchHandler","setHeaders","headersFinal","Array","entries","reduce","res","clearHeadersHandler","chunkArray","size","a","Math","ceil","fill","map","_","inx","slice","list","currentPage","setCurrentPage","chunkList","itemOnPage","setPageHandler","page","pageCount","token","parseJWT","base64","split","replace","jsonPayload","decodeURIComponent","atob","c","charCodeAt","join","args","module","exports","__WEBPACK_EXTERNAL_MODULE__297__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"mappings":"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","file":"index.min.js","sourcesContent":["import { useEffect } from \"react\";\nimport { usePrevState } from \"..\";\n\nexport const useChangeArrayLength = (arr: any[], fn: () => void) => {\n  const prevArrayLength = usePrevState(arr.length);\n\n  useEffect(() => {\n    if (prevArrayLength === undefined) return;\n\n    if (arr.length === prevArrayLength) return;\n\n    fn();\n  }, [arr.length, fn, prevArrayLength]);\n};\n","import { DependencyList, EffectCallback, useEffect, useRef } from \"react\";\n\nexport const useDidUpdate = (\n  effect: EffectCallback,\n  dependencies: DependencyList\n) => {\n  const hasMounted = useRef(true);\n\n  useEffect(() => {\n    if (hasMounted.current) {\n      hasMounted.current = false;\n      return;\n    }\n\n    return effect();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, dependencies);\n};\n","import { useCallback, useMemo, useReducer } from \"react\";\n\nexport interface State<TData, TError = any> {\n  status: \"init\" | \"request\" | \"failure\" | \"success\";\n  data?: TData;\n  error?: TError;\n}\n\nexport type Action<K extends string, V = void> = V extends void\n  ? { type: K }\n  : { type: K } & V;\n\nexport type ActionFetch<T> =\n  | Action<\"request\">\n  | Action<\"success\", { payload: T }>\n  | Action<\"failure\", { payload: any }>;\n\nexport const useFetchReducer = <TData, TError>() => {\n  const initialState = useMemo<State<TData, TError>>(\n    () => ({\n      status: \"init\",\n      error: undefined,\n      data: undefined,\n    }),\n    []\n  );\n\n  const fetchReducer = useCallback(\n    (\n      state: State<TData, TError>,\n      action: ActionFetch<TData>\n    ): State<TData, TError> => {\n      switch (action.type) {\n        case \"request\":\n          return { ...initialState, status: \"request\", data: state.data };\n        case \"success\":\n          return { ...initialState, status: \"success\", data: action.payload };\n        case \"failure\":\n          return { ...initialState, status: \"failure\", error: action.payload };\n        default:\n          return state;\n      }\n    },\n    [initialState]\n  );\n\n  const [state, dispatch] = useReducer(fetchReducer, initialState);\n\n  const request = useCallback(() => dispatch({ type: \"request\" }), []);\n\n  const success = useCallback(\n    (payload?) => dispatch({ type: \"success\", payload }),\n    []\n  );\n\n  const failure = useCallback(\n    (payload?) => dispatch({ type: \"failure\", payload }),\n    []\n  );\n\n  return {\n    state,\n    request,\n    success,\n    failure,\n  };\n};\n","import { useCallback, useEffect, useState } from \"react\";\nimport { tuple } from \"../utils/tuple\";\n\nexport const useLocalStorage = <T>(key: string, initialValue?: T) => {\n  const [storedValue, setStoredValue] = useState<T>(() => {\n    try {\n      const item = localStorage.getItem(key);\n\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.error(error);\n\n      return initialValue;\n    }\n  });\n\n  useEffect(() => {\n    try {\n      localStorage.setItem(key, JSON.stringify(storedValue));\n    } catch (error) {\n      console.log(error);\n    }\n  }, [key, storedValue]);\n\n  const setValue = useCallback((value: T) => setStoredValue(() => value), []);\n\n  return tuple(storedValue, setValue);\n};\n","import { useEffect, useRef } from \"react\";\n\nexport const usePrevState = <T>(state: T) => {\n  const prev = useRef<T>();\n\n  useEffect(() => {\n    prev.current = state;\n  }, [state]);\n\n  return prev.current;\n};\n","import { useState, useCallback } from \"react\";\nimport { tuple } from \"../utils/tuple\";\n\nexport const useTrigger = (initialState = false) => {\n  const [state, setState] = useState(initialState);\n\n  const onHandler = useCallback(() => setState(() => true), []);\n\n  const offHandler = useCallback(() => setState(() => false), []);\n\n  const togglerHandler = useCallback(() => setState((prev) => !prev), []);\n\n  return tuple(state, {\n    onHandler,\n    offHandler,\n    togglerHandler,\n  });\n};\n","import { useEffect, useRef } from \"react\";\n\nexport type IChangeProps<TProps extends Record<string, any>> = {\n  [key in keyof TProps]: {\n    from: TProps[key];\n    to: TProps[key];\n  };\n};\n\nexport const useWhyDidYouUpdate = <TProps extends Record<string, any>>(\n  props: TProps,\n  callback: (change: IChangeProps<TProps>) => void\n) => {\n  const previousProps = useRef<TProps>({} as TProps);\n\n  useEffect(() => {\n    if (previousProps.current) {\n      const allKeys = Object.keys({ ...previousProps.current, ...props });\n\n      const changeObj: IChangeProps<any> = {};\n\n      allKeys.forEach((key) => {\n        if (previousProps.current[key] !== props[key]) {\n          changeObj[key] = {\n            from: previousProps.current[key],\n            to: props[key],\n          };\n        }\n      });\n\n      if (Object.keys(changeObj).length) {\n        callback(changeObj);\n      }\n    }\n\n    previousProps.current = props;\n  }, [props, callback]);\n};\n","export { useFetch } from \"./use-fetch\";\nexport { useCallbackAsync } from \"./use-callback-async\";\nexport { useFetchReducer } from \"./hooks/use-fetch-reducer\";\nexport { useTrigger } from \"./hooks/use-trigger\";\nexport { useWhyDidYouUpdate } from \"./hooks/use-why-did-you-update\";\nexport { useParseJWT } from \"./use-parse-jwt\";\nexport { useLocalStorage } from \"./hooks/use-local-storage\";\nexport { usePagination } from \"./use-pagination\";\nexport { useDidUpdate } from \"./hooks/use-did-update\";\nexport { usePrevState } from \"./hooks/use-prev-state\";\nexport { useChangeArrayLength } from \"./hooks/use-change-array-length\";\n","import { useCallback, useEffect } from \"react\";\nimport { useTrigger } from \"../hooks/use-trigger\";\nimport { tuple } from \"../utils/tuple\";\nimport { useFetchReducer } from \"../hooks/use-fetch-reducer\";\nimport { useParams } from \"./use-params\";\n\nexport const useCallbackAsync = <\n  TData,\n  TError = any,\n  TParams extends any[] = any[]\n>(\n  callback: (...params: TParams) => Promise<TData>\n) => {\n  const { state, request, success, failure } = useFetchReducer<TData, TError>();\n\n  const [isStartFetch, { onHandler: fetchStart, offHandler: fetchFinish }] =\n    useTrigger();\n\n  const { params, setParamsHandler, clearParamsHandler } = useParams<TParams>();\n\n  useEffect(() => {\n    if (!isStartFetch) return;\n\n    let cancelRequest = false;\n\n    (async (...params: TParams) => {\n      try {\n        const data = await callback(...params);\n\n        if (cancelRequest) return;\n\n        fetchFinish();\n        success(data);\n        clearParamsHandler();\n      } catch (error) {\n        if (cancelRequest) return;\n\n        fetchFinish();\n        failure(error);\n        clearParamsHandler();\n      }\n    })(...params);\n\n    return () => {\n      cancelRequest = true;\n    };\n  }, [\n    callback,\n    failure,\n    fetchFinish,\n    isStartFetch,\n    success,\n    params,\n    clearParamsHandler,\n  ]);\n\n  const doFetch = useCallback(\n    (...params: TParams) => {\n      setParamsHandler(params);\n      request();\n      fetchStart();\n    },\n    [request, fetchStart, setParamsHandler]\n  );\n\n  return tuple(state, doFetch);\n};\n","import { useCallback, useState } from \"react\";\n\nexport const useParams = <TParams extends any[] = any[]>() => {\n  const [params, setParams] = useState<TParams>([] as any);\n\n  const setParamsHandler = useCallback((params: TParams) => {\n    setParams(() => params);\n  }, []);\n\n  const clearParamsHandler = useCallback(() => {\n    setParams(() => [] as any);\n  }, []);\n\n  return {\n    params,\n    setParamsHandler,\n    clearParamsHandler,\n  };\n};\n","import { useCallbackAsync } from \"./../use-callback-async/index\";\nimport { useCallback } from \"react\";\nimport { tuple } from \"../utils/tuple\";\nimport { useHeaders } from \"./use-headers\";\n\ninterface UseFetchOption extends RequestInit {\n  responseType?: \"text\" | \"json\" | \"formData\" | \"blob\" | \"arrayBuffer\";\n}\n\nconst fetchHandler = async (\n  url: string,\n  options: UseFetchOption,\n  setHeadersHandlerCallback: (headers: Headers) => void\n) => {\n  const { responseType, ...optionsFetch } = options;\n\n  const response = await fetch(url.toString(), optionsFetch);\n\n  setHeadersHandlerCallback(response.headers);\n\n  if (!response.ok) {\n    const body = await response.json();\n    throw body;\n  }\n\n  let data = null;\n\n  switch (responseType) {\n    case \"text\":\n      data = await response.text();\n      break;\n    case \"json\":\n      data = await response.json();\n      break;\n    case \"formData\":\n      data = await response.formData();\n      break;\n    case \"blob\":\n      data = await response.blob();\n      break;\n    case \"arrayBuffer\":\n      data = await response.arrayBuffer();\n      break;\n    default:\n      throw new Error(\"Not found type of response\");\n  }\n\n  return data;\n};\n\nexport const useFetch = <TData, TError = any>(url: string) => {\n  const { headers, setHeadersHandler } = useHeaders();\n\n  const [state, doFetch] = useCallbackAsync<\n    TData,\n    TError,\n    [string, UseFetchOption, (headers: Headers) => void]\n  >(fetchHandler);\n\n  const doFetchHandler = useCallback(\n    (options?: UseFetchOption) =>\n      doFetch(\n        url,\n        {\n          responseType: \"json\",\n          ...options,\n        },\n        setHeadersHandler\n      ),\n    [doFetch, setHeadersHandler, url]\n  );\n\n  return tuple(state, doFetchHandler, headers);\n};\n\n/* export const useFetch = <TData, TError = any>(url: string) => {\n  const [options, setOptions] = useState<UseFetchOption>({} as UseFetchOption);\n\n  const { headers, setHeadersHandler, clearHeadersHandler } = useHeaders();\n\n  const { state, request, success, failure } = useFetchReducer<TData, TError>();\n\n  const [isFetch, { onHandler: fetchStart, offHandler: fetchFinish }] =\n    useTrigger();\n\n  useEffect(() => {\n    if (!isFetch) return;\n\n    let cancelRequest = false;\n\n    (async () => {\n      try {\n        const { responseType, ...optionsFetch } = options;\n\n        const response = await fetch(url.toString(), optionsFetch);\n\n        setHeadersHandler(response.headers);\n\n        if (!response.ok) {\n          const body = await response.json();\n          throw body;\n        }\n\n        let data = null;\n\n        switch (responseType) {\n          case \"text\":\n            data = await response.text();\n            break;\n          case \"json\":\n            data = await response.json();\n            break;\n          case \"formData\":\n            data = await response.formData();\n            break;\n          case \"blob\":\n            data = await response.blob();\n            break;\n          case \"arrayBuffer\":\n            data = await response.arrayBuffer();\n            break;\n          default:\n            throw new Error(\"Not found type of response\");\n        }\n\n        if (cancelRequest) return;\n\n        fetchFinish();\n        success(data);\n      } catch (error) {\n        if (cancelRequest) return;\n\n        fetchFinish();\n        clearHeadersHandler();\n        failure(error);\n      }\n    })();\n\n    return () => {\n      cancelRequest = true;\n    };\n  }, [\n    clearHeadersHandler,\n    failure,\n    isFetch,\n    options,\n    setHeadersHandler,\n    success,\n    url,\n    fetchFinish,\n  ]);\n\n  const doFetch = useCallback(\n    (options?: UseFetchOption) => {\n      request();\n\n      setOptions(() => ({\n        responseType: \"json\",\n        ...options,\n      }));\n\n      fetchStart();\n    },\n    [request, fetchStart]\n  );\n\n  return tuple(state, doFetch, headers);\n}; */\n","import { useCallback, useState } from \"react\";\n\ntype useHeadersState = {\n  [key: string]: string;\n} | null;\n\nexport const useHeaders = () => {\n  const [headers, setHeaders] = useState<useHeadersState>(null);\n\n  const setHeadersHandler = useCallback((headers: Headers) => {\n    const headersFinal = Array.from(headers.entries()).reduce(\n      (res, [key, value]) => ({\n        ...res,\n        [key]: value,\n      }),\n      {}\n    );\n\n    setHeaders(() => headersFinal);\n  }, []);\n\n  const clearHeadersHandler = useCallback(() => {\n    setHeaders(() => null);\n  }, []);\n\n  return {\n    headers,\n    setHeadersHandler,\n    clearHeadersHandler,\n  };\n};\n","export const chunkArray = <T>(arr: T[], size = 1) => {\n  const a = arr || [];\n\n  return Array(Math.ceil(a.length / size))\n    .fill([])\n    .map((_, inx) => a.slice(inx * size, inx * size + size));\n};\n","import { chunkArray } from \"./chunkFromArray\";\nimport { useCallback, useMemo, useState } from \"react\";\n\nexport const usePagination = <T>(size = 5, list: T[]) => {\n  const [currentPage, setCurrentPage] = useState(1);\n\n  const chunkList = useMemo(() => chunkArray(list, size), [list, size]);\n\n  const itemOnPage = useMemo(\n    () => chunkList[currentPage - 1] || chunkList[0] || [],\n    [chunkList, currentPage]\n  );\n\n  const setPageHandler = useCallback(\n    (page: number) => {\n      if (!chunkList[page - 1]) {\n        setCurrentPage(1);\n      } else {\n        setCurrentPage(() => page);\n      }\n    },\n    [chunkList]\n  );\n\n  return {\n    itemOnPage,\n    currentPage,\n    pageCount: chunkList.length,\n    setPageHandler,\n  };\n};\n","import { useMemo } from \"react\";\nimport { parseJWT } from \"./parse-jwt\";\n\nexport const useParseJWT = <T>(token: string) => {\n  const JWT = useMemo(() => parseJWT<T>(token), [token]);\n\n  return JWT;\n};\n","export const parseJWT = <T>(token: string): T | null => {\n  try {\n    if (!token) return null;\n\n    const base64Url = token.split(\".\")[1];\n    const base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const jsonPayload = decodeURIComponent(\n      atob(base64)\n        .split(\"\")\n        .map((c) => \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2))\n        .join(\"\")\n    );\n\n    return JSON.parse(jsonPayload);\n  } catch (error) {\n    console.log(error);\n    return null;\n  }\n};\n","export const tuple = <T extends unknown[]>(...args: T): T => args;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__297__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(447);\n"],"sourceRoot":""}