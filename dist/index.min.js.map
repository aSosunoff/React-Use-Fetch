{"version":3,"sources":["webpack:///./index.ts","webpack:///external \"react\"","webpack:///webpack/bootstrap","webpack:///webpack/startup"],"names":["useFetch","url","isCache","useState","options","setOptions","cache","useRef","isFetch","setFetch","initialState","useMemo","status","error","undefined","data","fetchReducer","useCallback","state","action","type","payload","useReducer","dispatch","request","success","failure","useEffect","cancelRequest","current","fetch","toString","response","ok","json","responseType","text","formData","blob","arrayBuffer","Error","module","exports","__WEBPACK_EXTERNAL_MODULE__297__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"mappings":"yuDAAA,aAgCa,EAAAA,SAAW,SACtBC,EACAC,QAAA,IAAAA,OAAA,GAEM,MAAwB,EAAAC,SAAyB,IAAhDC,EAAO,KAAEC,EAAU,KAEpBC,EAAQ,EAAAC,OAAqB,IAE7B,EAAsB,EAAAJ,UAAS,GAA9BK,EAAO,KAAEC,EAAQ,KAElBC,EAAe,EAAAC,SACnB,WAAM,MAAC,CACLC,OAAQ,OACRC,WAAOC,EACPC,UAAMD,KAER,IAGIE,EAAe,EAAAC,aACnB,SACEC,EACAC,GAEA,OAAQA,EAAOC,MACb,IAAK,UACH,cAAYV,GAAY,CAAEE,OAAQ,YACpC,IAAK,UACH,cAAYF,GAAY,CAAEE,OAAQ,UAAWG,KAAMI,EAAOE,UAC5D,IAAK,UACH,cAAYX,GAAY,CAAEE,OAAQ,UAAWC,MAAOM,EAAOE,UAC7D,QACE,OAAOH,KAGb,CAACR,IAGG,EAAoB,EAAAY,WAAWN,EAAcN,GAA5CQ,EAAK,KAAEK,EAAQ,KAChBC,EAAU,EAAAP,aAAY,WAAM,OAAAM,EAAS,CAAEH,KAAX,cAA+B,IAC3DK,EAAU,EAAAR,aACd,SAACI,GAAY,OAAAE,EAAS,CAAEH,KAAM,UAAWC,QAA5B,MACb,IAEIK,EAAU,EAAAT,aACd,SAACI,GAAY,OAAAE,EAAS,CAAEH,KAAM,UAAWC,QAA5B,MACb,IA2EF,OAxEA,EAAAM,WAAU,WACR,GAAK1B,GAAQO,EAAb,CAIA,IAAIoB,GAAgB,EAsDpB,OApDgB,mC,0DAGd,OAFAJ,IAEItB,GAAWI,EAAMuB,QAAQ5B,IAC3BQ,GAAS,WAAM,aACdmB,GAAiBH,EAAQnB,EAAMuB,QAAQ5B,IACxC,KAGe,GAAM6B,MAAM7B,EAAI8B,WAAY3B,I,cAAvC4B,EAAW,UAEHC,GAAV,MACW,GAAMD,EAASE,Q,OAC5B,MADa,S,cAIXnB,EAAO,KAEHX,EAAQ+B,c,IACT,mB,IAGA,mB,IAGA,uB,IAGA,oB,IAGA,2B,oBAXI,SAAMH,EAASI,Q,OACtB,OADArB,EAAO,SACP,O,OAEO,SAAMiB,EAASE,Q,OACtB,OADAnB,EAAO,SACP,O,OAEO,SAAMiB,EAASK,Y,OACtB,OADAtB,EAAO,SACP,O,QAEO,SAAMiB,EAASM,Q,QACtB,OADAvB,EAAO,SACP,O,QAEO,SAAMiB,EAASO,e,QACtB,OADAxB,EAAO,SACP,O,QAEA,MAAM,IAAIyB,MAAM,8B,eAGfZ,IACHtB,EAAMuB,QAAQ5B,GAAOc,EACrBN,GAAS,WAAM,YACfgB,EAAQV,I,WAIL,OAAS,SAACF,GACVe,IACHnB,GAAS,WAAM,YACfiB,EAAQb,OAIL,WACLe,GAAgB,MAEjB,CAACF,EAASxB,EAASM,EAASJ,EAASoB,EAASC,EAASxB,IAUnD,CAACiB,EARQ,EAAAD,aACd,SAACb,QAAA,IAAAA,MAAA,CAA4B+B,aAAc,SACzC9B,GAAW,WAAM,OAAAD,KACjBK,GAAS,WAAM,cAEjB,O,QCtJJgC,EAAOC,QAAUC,ICCbC,EAA2B,G,OAG/B,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBhC,IAAjBiC,EACH,OAAOA,EAAaL,QAGrB,IAAID,EAASG,EAAyBE,GAAY,CAGjDJ,QAAS,IAOV,OAHAM,EAAoBF,GAAUG,KAAKR,EAAOC,QAASD,EAAQA,EAAOC,QAASG,GAGpEJ,EAAOC,QClBWG,CAAoB,M","file":"index.min.js","sourcesContent":["import {\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n} from \"react\";\n\ntype Action<K extends string, V = void> = V extends void\n  ? { type: K }\n  : { type: K } & V;\n\ntype ActionFetch<T> =\n  | Action<\"request\">\n  | Action<\"success\", { payload: T }>\n  | Action<\"failure\", { payload: any }>;\n\nexport interface State<T, TError = any> {\n  status: \"init\" | \"request\" | \"failure\" | \"success\";\n  data?: T;\n  error?: TError;\n}\n\ninterface Cache<T> {\n  [url: string]: T;\n}\n\ninterface UseFetchOption extends RequestInit {\n  responseType?: \"text\" | \"json\" | \"formData\" | \"blob\" | \"arrayBuffer\";\n}\n\nexport const useFetch = <TData, TError = any>(\n  url: string,\n  isCache = false\n): [State<TData, TError>, (options?: UseFetchOption) => void] => {\n  const [options, setOptions] = useState<UseFetchOption>({} as UseFetchOption);\n\n  const cache = useRef<Cache<TData>>({});\n\n  const [isFetch, setFetch] = useState(false);\n\n  const initialState = useMemo<State<TData, TError>>(\n    () => ({\n      status: \"init\",\n      error: undefined,\n      data: undefined,\n    }),\n    []\n  );\n\n  const fetchReducer = useCallback(\n    (\n      state: State<TData, TError>,\n      action: ActionFetch<TData>\n    ): State<TData, TError> => {\n      switch (action.type) {\n        case \"request\":\n          return { ...initialState, status: \"request\" };\n        case \"success\":\n          return { ...initialState, status: \"success\", data: action.payload };\n        case \"failure\":\n          return { ...initialState, status: \"failure\", error: action.payload };\n        default:\n          return state;\n      }\n    },\n    [initialState]\n  );\n\n  const [state, dispatch] = useReducer(fetchReducer, initialState);\n  const request = useCallback(() => dispatch({ type: \"request\" }), []);\n  const success = useCallback(\n    (payload) => dispatch({ type: \"success\", payload }),\n    []\n  );\n  const failure = useCallback(\n    (payload) => dispatch({ type: \"failure\", payload }),\n    []\n  );\n\n  useEffect(() => {\n    if (!url || !isFetch) {\n      return;\n    }\n\n    let cancelRequest = false;\n\n    const doFetch = async () => {\n      request();\n\n      if (isCache && cache.current[url]) {\n        setFetch(() => false);\n        !cancelRequest && success(cache.current[url]);\n        return;\n      }\n\n      const response = await fetch(url.toString(), options);\n\n      if (!response.ok) {\n        const body = await response.json();\n        throw body;\n      }\n\n      let data = null;\n\n      switch (options.responseType) {\n        case \"text\":\n          data = await response.text();\n          break;\n        case \"json\":\n          data = await response.json();\n          break;\n        case \"formData\":\n          data = await response.formData();\n          break;\n        case \"blob\":\n          data = await response.blob();\n          break;\n        case \"arrayBuffer\":\n          data = await response.arrayBuffer();\n          break;\n        default:\n          throw new Error(\"Not found type of response\");\n      }\n\n      if (!cancelRequest) {\n        cache.current[url] = data;\n        setFetch(() => false);\n        success(data);\n      }\n    };\n\n    doFetch().catch((error) => {\n      if (!cancelRequest) {\n        setFetch(() => false);\n        failure(error);\n      }\n    });\n\n    return () => {\n      cancelRequest = true;\n    };\n  }, [failure, isCache, isFetch, options, request, success, url]);\n\n  const doFetch = useCallback(\n    (options: UseFetchOption = { responseType: \"json\" }) => {\n      setOptions(() => options);\n      setFetch(() => true);\n    },\n    []\n  );\n\n  return [state, doFetch];\n};\n","module.exports = __WEBPACK_EXTERNAL_MODULE__297__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(447);\n"],"sourceRoot":""}