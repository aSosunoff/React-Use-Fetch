{"version":3,"sources":["webpack:///./hooks/use-did-update.ts","webpack:///./hooks/use-fetch-reducer.ts","webpack:///./hooks/use-local-storage.ts","webpack:///./hooks/use-trigger.ts","webpack:///./hooks/use-why-did-you-update.ts","webpack:///./use-callback-async/index.ts","webpack:///./use-callback-async/use-params.ts","webpack:///./use-fetch/index.ts","webpack:///./use-fetch/use-headers.ts","webpack:///./use-pagination/chunkFromArray.ts","webpack:///./use-pagination/index.ts","webpack:///./use-parse-jwt/index.ts","webpack:///./use-parse-jwt/parse-jwt.ts","webpack:///./utils/tuple.ts","webpack:///external \"react\"","webpack:///webpack/bootstrap","webpack:///./index.ts"],"names":["useDidUpdate","effect","dependencies","hasMounted","useRef","useEffect","current","useFetchReducer","initialState","useMemo","status","error","undefined","data","fetchReducer","useCallback","state","action","type","payload","useReducer","dispatch","request","success","failure","useLocalStorage","key","initialValue","useState","item","localStorage","getItem","JSON","parse","console","storedValue","setStoredValue","setItem","stringify","log","setValue","value","tuple","useTrigger","setState","onHandler","offHandler","togglerHandler","prev","useWhyDidYouUpdate","props","callback","previousProps","allKeys","Object","keys","forEach","from","to","length","useCallbackAsync","isStartFetch","fetchStart","fetchFinish","useParams","params","setParamsHandler","clearParamsHandler","cancelRequest","doFetch","setParams","fetchHandler","url","options","setHeadersHandlerCallback","responseType","optionsFetch","fetch","toString","response","headers","ok","json","text","formData","blob","arrayBuffer","Error","useFetch","useHeaders","setHeadersHandler","doFetchHandler","setHeaders","headersFinal","Array","entries","reduce","res","clearHeadersHandler","chunkArray","arr","size","a","Math","ceil","fill","map","_","inx","slice","usePagination","list","currentPage","setCurrentPage","chunkList","itemOnPage","setPageHandler","page","pageCount","useParseJWT","token","parseJWT","base64","split","replace","jsonPayload","decodeURIComponent","atob","c","charCodeAt","join","args","module","exports","__WEBPACK_EXTERNAL_MODULE__297__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"mappings":"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","file":"index.min.js","sourcesContent":["import { DependencyList, EffectCallback, useEffect, useRef } from \"react\";\n\nexport const useDidUpdate = (\n  effect: EffectCallback,\n  dependencies: DependencyList\n) => {\n  const hasMounted = useRef(true);\n\n  useEffect(() => {\n    if (hasMounted.current) {\n      hasMounted.current = false;\n      return;\n    }\n\n    return effect();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, dependencies);\n};\n","import { useCallback, useMemo, useReducer } from \"react\";\n\nexport interface State<TData, TError = any> {\n  status: \"init\" | \"request\" | \"failure\" | \"success\";\n  data?: TData;\n  error?: TError;\n}\n\nexport type Action<K extends string, V = void> = V extends void\n  ? { type: K }\n  : { type: K } & V;\n\nexport type ActionFetch<T> =\n  | Action<\"request\">\n  | Action<\"success\", { payload: T }>\n  | Action<\"failure\", { payload: any }>;\n\nexport const useFetchReducer = <TData, TError>() => {\n  const initialState = useMemo<State<TData, TError>>(\n    () => ({\n      status: \"init\",\n      error: undefined,\n      data: undefined,\n    }),\n    []\n  );\n\n  const fetchReducer = useCallback(\n    (\n      state: State<TData, TError>,\n      action: ActionFetch<TData>\n    ): State<TData, TError> => {\n      switch (action.type) {\n        case \"request\":\n          return { ...initialState, status: \"request\", data: state.data };\n        case \"success\":\n          return { ...initialState, status: \"success\", data: action.payload };\n        case \"failure\":\n          return { ...initialState, status: \"failure\", error: action.payload };\n        default:\n          return state;\n      }\n    },\n    [initialState]\n  );\n\n  const [state, dispatch] = useReducer(fetchReducer, initialState);\n\n  const request = useCallback(() => dispatch({ type: \"request\" }), []);\n\n  const success = useCallback(\n    (payload?) => dispatch({ type: \"success\", payload }),\n    []\n  );\n\n  const failure = useCallback(\n    (payload?) => dispatch({ type: \"failure\", payload }),\n    []\n  );\n\n  return {\n    state,\n    request,\n    success,\n    failure,\n  };\n};\n","import { useCallback, useEffect, useState } from \"react\";\nimport { tuple } from \"../utils/tuple\";\n\nexport const useLocalStorage = <T>(key: string, initialValue?: T) => {\n  const [storedValue, setStoredValue] = useState<T>(() => {\n    try {\n      const item = localStorage.getItem(key);\n\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.error(error);\n\n      return initialValue;\n    }\n  });\n\n  useEffect(() => {\n    try {\n      localStorage.setItem(key, JSON.stringify(storedValue));\n    } catch (error) {\n      console.log(error);\n    }\n  }, [key, storedValue]);\n\n  const setValue = useCallback((value: T) => setStoredValue(() => value), []);\n\n  return tuple(storedValue, setValue);\n};\n","import { useState, useCallback } from \"react\";\nimport { tuple } from \"../utils/tuple\";\n\nexport const useTrigger = (initialState = false) => {\n  const [state, setState] = useState(initialState);\n\n  const onHandler = useCallback(() => setState(() => true), []);\n\n  const offHandler = useCallback(() => setState(() => false), []);\n\n  const togglerHandler = useCallback(() => setState((prev) => !prev), []);\n\n  return tuple(state, {\n    onHandler,\n    offHandler,\n    togglerHandler,\n  });\n};\n","import { useEffect, useRef } from \"react\";\n\nexport type IChangeProps<TProps extends Record<string, any>> = {\n  [key in keyof TProps]: {\n    from: TProps[key];\n    to: TProps[key];\n  };\n};\n\nexport const useWhyDidYouUpdate = <TProps extends Record<string, any>>(\n  props: TProps,\n  callback: (change: IChangeProps<TProps>) => void\n) => {\n  const previousProps = useRef<TProps>({} as TProps);\n\n  useEffect(() => {\n    if (previousProps.current) {\n      const allKeys = Object.keys({ ...previousProps.current, ...props });\n\n      const changeObj: IChangeProps<any> = {};\n\n      allKeys.forEach((key) => {\n        if (previousProps.current[key] !== props[key]) {\n          changeObj[key] = {\n            from: previousProps.current[key],\n            to: props[key],\n          };\n        }\n      });\n\n      if (Object.keys(changeObj).length) {\n        callback(changeObj);\n      }\n    }\n\n    previousProps.current = props;\n  }, [props, callback]);\n};\n","import { useCallback, useEffect } from \"react\";\nimport { useTrigger } from \"../hooks/use-trigger\";\nimport { tuple } from \"../utils/tuple\";\nimport { useFetchReducer } from \"../hooks/use-fetch-reducer\";\nimport { useParams } from \"./use-params\";\n\nexport const useCallbackAsync = <\n  TData,\n  TError = any,\n  TParams extends any[] = any[]\n>(\n  callback: (...params: TParams) => Promise<TData>\n) => {\n  const { state, request, success, failure } = useFetchReducer<TData, TError>();\n\n  const [isStartFetch, { onHandler: fetchStart, offHandler: fetchFinish }] =\n    useTrigger();\n\n  const { params, setParamsHandler, clearParamsHandler } = useParams<TParams>();\n\n  useEffect(() => {\n    if (!isStartFetch) return;\n\n    let cancelRequest = false;\n\n    (async (...params: TParams) => {\n      try {\n        const data = await callback(...params);\n\n        if (cancelRequest) return;\n\n        fetchFinish();\n        success(data);\n        clearParamsHandler();\n      } catch (error) {\n        if (cancelRequest) return;\n\n        fetchFinish();\n        failure(error);\n        clearParamsHandler();\n      }\n    })(...params);\n\n    return () => {\n      cancelRequest = true;\n    };\n  }, [\n    callback,\n    failure,\n    fetchFinish,\n    isStartFetch,\n    success,\n    params,\n    clearParamsHandler,\n  ]);\n\n  const doFetch = useCallback(\n    (...params: TParams) => {\n      setParamsHandler(params);\n      request();\n      fetchStart();\n    },\n    [request, fetchStart, setParamsHandler]\n  );\n\n  return tuple(state, doFetch);\n};\n","import { useCallback, useState } from \"react\";\n\nexport const useParams = <TParams extends any[] = any[]>() => {\n  const [params, setParams] = useState<TParams>([] as any);\n\n  const setParamsHandler = useCallback((params: TParams) => {\n    setParams(() => params);\n  }, []);\n\n  const clearParamsHandler = useCallback(() => {\n    setParams(() => [] as any);\n  }, []);\n\n  return {\n    params,\n    setParamsHandler,\n    clearParamsHandler,\n  };\n};\n","import { useCallbackAsync } from \"./../use-callback-async/index\";\nimport { useCallback } from \"react\";\nimport { tuple } from \"../utils/tuple\";\nimport { useHeaders } from \"./use-headers\";\n\ninterface UseFetchOption extends RequestInit {\n  responseType?: \"text\" | \"json\" | \"formData\" | \"blob\" | \"arrayBuffer\";\n}\n\nconst fetchHandler = async (\n  url: string,\n  options: UseFetchOption,\n  setHeadersHandlerCallback: (headers: Headers) => void\n) => {\n  const { responseType, ...optionsFetch } = options;\n\n  const response = await fetch(url.toString(), optionsFetch);\n\n  setHeadersHandlerCallback(response.headers);\n\n  if (!response.ok) {\n    const body = await response.json();\n    throw body;\n  }\n\n  let data = null;\n\n  switch (responseType) {\n    case \"text\":\n      data = await response.text();\n      break;\n    case \"json\":\n      data = await response.json();\n      break;\n    case \"formData\":\n      data = await response.formData();\n      break;\n    case \"blob\":\n      data = await response.blob();\n      break;\n    case \"arrayBuffer\":\n      data = await response.arrayBuffer();\n      break;\n    default:\n      throw new Error(\"Not found type of response\");\n  }\n\n  return data;\n};\n\nexport const useFetch = <TData, TError = any>(url: string) => {\n  const { headers, setHeadersHandler } = useHeaders();\n\n  const [state, doFetch] = useCallbackAsync<\n    TData,\n    TError,\n    [string, UseFetchOption, (headers: Headers) => void]\n  >(fetchHandler);\n\n  const doFetchHandler = useCallback(\n    (options?: UseFetchOption) =>\n      doFetch(\n        url,\n        {\n          responseType: \"json\",\n          ...options,\n        },\n        setHeadersHandler\n      ),\n    [doFetch, setHeadersHandler, url]\n  );\n\n  return tuple(state, doFetchHandler, headers);\n};\n\n/* export const useFetch = <TData, TError = any>(url: string) => {\n  const [options, setOptions] = useState<UseFetchOption>({} as UseFetchOption);\n\n  const { headers, setHeadersHandler, clearHeadersHandler } = useHeaders();\n\n  const { state, request, success, failure } = useFetchReducer<TData, TError>();\n\n  const [isFetch, { onHandler: fetchStart, offHandler: fetchFinish }] =\n    useTrigger();\n\n  useEffect(() => {\n    if (!isFetch) return;\n\n    let cancelRequest = false;\n\n    (async () => {\n      try {\n        const { responseType, ...optionsFetch } = options;\n\n        const response = await fetch(url.toString(), optionsFetch);\n\n        setHeadersHandler(response.headers);\n\n        if (!response.ok) {\n          const body = await response.json();\n          throw body;\n        }\n\n        let data = null;\n\n        switch (responseType) {\n          case \"text\":\n            data = await response.text();\n            break;\n          case \"json\":\n            data = await response.json();\n            break;\n          case \"formData\":\n            data = await response.formData();\n            break;\n          case \"blob\":\n            data = await response.blob();\n            break;\n          case \"arrayBuffer\":\n            data = await response.arrayBuffer();\n            break;\n          default:\n            throw new Error(\"Not found type of response\");\n        }\n\n        if (cancelRequest) return;\n\n        fetchFinish();\n        success(data);\n      } catch (error) {\n        if (cancelRequest) return;\n\n        fetchFinish();\n        clearHeadersHandler();\n        failure(error);\n      }\n    })();\n\n    return () => {\n      cancelRequest = true;\n    };\n  }, [\n    clearHeadersHandler,\n    failure,\n    isFetch,\n    options,\n    setHeadersHandler,\n    success,\n    url,\n    fetchFinish,\n  ]);\n\n  const doFetch = useCallback(\n    (options?: UseFetchOption) => {\n      request();\n\n      setOptions(() => ({\n        responseType: \"json\",\n        ...options,\n      }));\n\n      fetchStart();\n    },\n    [request, fetchStart]\n  );\n\n  return tuple(state, doFetch, headers);\n}; */\n","import { useCallback, useState } from \"react\";\n\ntype useHeadersState = {\n  [key: string]: string;\n} | null;\n\nexport const useHeaders = () => {\n  const [headers, setHeaders] = useState<useHeadersState>(null);\n\n  const setHeadersHandler = useCallback((headers: Headers) => {\n    const headersFinal = Array.from(headers.entries()).reduce(\n      (res, [key, value]) => ({\n        ...res,\n        [key]: value,\n      }),\n      {}\n    );\n\n    setHeaders(() => headersFinal);\n  }, []);\n\n  const clearHeadersHandler = useCallback(() => {\n    setHeaders(() => null);\n  }, []);\n\n  return {\n    headers,\n    setHeadersHandler,\n    clearHeadersHandler,\n  };\n};\n","export const chunkArray = <T>(arr: T[], size = 1) => {\n  const a = arr || [];\n\n  return Array(Math.ceil(a.length / size))\n    .fill([])\n    .map((_, inx) => a.slice(inx * size, inx * size + size));\n};\n","import { chunkArray } from \"./chunkFromArray\";\nimport { useCallback, useMemo, useState } from \"react\";\n\nexport const usePagination = <T>(size = 5, list: T[]) => {\n  const [currentPage, setCurrentPage] = useState(1);\n\n  const chunkList = useMemo(() => chunkArray(list, size), [list, size]);\n\n  const itemOnPage = useMemo(\n    () => chunkList[currentPage - 1] || chunkList[0] || [],\n    [chunkList, currentPage]\n  );\n\n  const setPageHandler = useCallback(\n    (page: number) => {\n      if (!chunkList[page - 1]) {\n        setCurrentPage(1);\n      } else {\n        setCurrentPage(() => page);\n      }\n    },\n    [chunkList]\n  );\n\n  return {\n    itemOnPage,\n    currentPage,\n    pageCount: chunkList.length,\n    setPageHandler,\n  };\n};\n","import { useMemo } from \"react\";\nimport { parseJWT } from \"./parse-jwt\";\n\nexport const useParseJWT = <T>(token: string) => {\n  const JWT = useMemo(() => parseJWT<T>(token), [token]);\n\n  return JWT;\n};\n","export const parseJWT = <T>(token: string): T | null => {\n  try {\n    if (!token) return null;\n\n    const base64Url = token.split(\".\")[1];\n    const base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const jsonPayload = decodeURIComponent(\n      atob(base64)\n        .split(\"\")\n        .map((c) => \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2))\n        .join(\"\")\n    );\n\n    return JSON.parse(jsonPayload);\n  } catch (error) {\n    console.log(error);\n    return null;\n  }\n};\n","export const tuple = <T extends unknown[]>(...args: T): T => args;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__297__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","export { useFetch } from \"./use-fetch\";\nexport { useCallbackAsync } from \"./use-callback-async\";\nexport { useFetchReducer } from \"./hooks/use-fetch-reducer\";\nexport { useTrigger } from \"./hooks/use-trigger\";\nexport { useWhyDidYouUpdate } from \"./hooks/use-why-did-you-update\";\nexport { useParseJWT } from \"./use-parse-jwt\";\nexport { useLocalStorage } from \"./hooks/use-local-storage\";\nexport { usePagination } from \"./use-pagination\";\nexport { useDidUpdate } from \"./hooks/use-did-update\";\n"],"sourceRoot":""}